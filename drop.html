<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/css/toastr.min.css">
<script src="//unpkg.com/twitch-js@>2.0.0-beta.31"></script>
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/js/toastr.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/p5@1.4.0/lib/p5.js"></script>
<script src="token.js"></script>
<script src="libraries/matter.js"></script>
<script src="libraries/helpers.js"></script>
<script lang="javascript">
  const Engine = Matter.Engine;
  const Render = Matter.Render;
  const World = Matter.World;
  const MBody = Matter.Body;
  const Bodies = Matter.Bodies;
  const Vertices = Matter.Vertices;
  const Runner = Matter.Runner;
  const Constraint = Matter.Constraint;
  const Composite = Matter.Composite;
  const Vector = Matter.Vector;
  const Query = Matter.Query;
  const drawBody = Helpers.drawBody;

  const username = 'jwalter';
  const { chat } = new window.TwitchJs({ username, token: twitchToken });
  let myCircles = [];
  let players = [];
  let targetX = 0;
  let targetWidth;
  let targetHeight;
  let highScorer;

  let boxA;
  let boxB;
  let rightWall;
  let leftWall;
  let ground;
  let floor;

  chat.connect().then(globalUserState => {
    const channel = '#jwalter';    
    chat.join(channel).then(channelState => {
      toastr.options = {
        "positionClass": "toast-bottom-right",
        "newestOnTop": false,
      }

      chat.on('PRIVMSG', privateMessage => {
        console.dir(privateMessage.message);
        console.log(privateMessage.message.indexOf('!circle'));
        if (privateMessage.message.indexOf('!circle') === 0) {
          console.log("Adding circle");
          myCircles.push(new Circle());
        } else if(privateMessage.message.indexOf('!drop') === 0) {
          const newPlayer = new Player(privateMessage.username);
          players.push(newPlayer);
          World.add(engine.world, newPlayer.comp);
          // World.add(engine.world, newPlayer.chute);
        }
      })
    });

  });

  function setup() {
    this.width = windowWidth;
    this.height = windowHeight;
    this.targetX = windowWidth / 2;
    this.targetWidth = 200;
    this.targetHeight = 40;
    createCanvas(windowWidth, windowHeight);

     // create an engine
    engine = Engine.create();
    runner = Runner.create();
    
    rightWall = Bodies.rectangle(this.width - 10, this.height / 2, 10, this.height, {
      isStatic: true
    });
    leftWall = Bodies.rectangle(0, this.height / 2, 10, this.height, {
      isStatic: true
    });
    floor = Bodies.rectangle(this.width /2 , this.height  - 10, this.width, 10, {
      isStatic: true
    });
    
    World.add(engine.world, [rightWall, leftWall, floor]);
    Runner.run(runner, engine);
  }
  function draw() {
    clear();
    push();
    myCircles.forEach(c => {
      fill(c.color);
      circle(c.x, c.y, c.radius);
    });
    pop();
    push();
    fill('#ff0000');
    rect(this.targetX - (this.targetWidth / 2), windowHeight - this.targetHeight, this.targetWidth, this.targetHeight);
    pop();
    players.forEach(p => {
      push();
      p.draw();
      pop();
      // if (p.active || !p.loser) {
      //   this.updatePlayerState(p);
      // }
    });

    fill(128);
    drawBody(rightWall);
    drawBody(leftWall);
    drawBody(floor);
  }

  function updatePlayerState(player) {
    //if (player.y > windowHeight - this.targetHeight) {
      let score;
      if (player.score === undefined) {
        score = round(100 - abs(this.targetX - player.playerBody.position.x), 2);
        console.log(`${player.name} scored ${score}`);
        player.score = score;
        player.active = false;
      }
      if (this.highScorer === undefined || this.highScorer.score < player.score) {
        if (this.highScorer !== undefined) {
          this.highScorer.loser = true;
        }
        this.highScorer = player;
      } else if (this.highScorer !== player) {
        player.loser = true;
      }
    //}
  }

  class Player {
    x = random(windowWidth);
    y = 100;
    xSpeed = random(-5, 5);
    ySpeed = 2;
    name;
    active = true;
    loser = false;
    color = color(random(255), random(255), random(255));
    loserColor = color(0, 42);
    playerBody;
    comp;
    chuteForce = random(-0.1, 0.1);

    constructor(name) {
      this.name = name;
      this.playerBody = Bodies.circle(this.x, this.y, 25, 
      { 
        restitution: 0.5,
        density: 0.01
      }
      );
      this.chute = Bodies.fromVertices(this.x, this.y - 100, Vertices.fromPath('35 7 19 17 14 38 14 58 25 79 45 85 65 84 65 66 46 67 34 59 30 44 33 29 45 23 66 23 66 7 53 7'),
      { 
        frictionAir: 1 
      });
      MBody.rotate(this.chute, Math.PI / 2);
      const leftConstraint = Constraint.create({
        bodyA: this.chute,
        bodyB: this.playerBody,
        pointA: Vector.create(-20, 0),
        pointB: Vector.create(-10, 0)
      });
      const rightConstraint = Constraint.create({
        bodyA: this.chute,
        bodyB: this.playerBody,
        pointA: Vector.create(20, 0),
        pointB: Vector.create(10, 0)
      });
      this.comp = Composite.create();
      Composite.add(this.comp, [this.playerBody, this.chute, leftConstraint, rightConstraint]);
      //this.playerBody.force = Vector.create(0.1, 0);
      //this.chute.force = Vector.create(0.1, 0);
    }

    draw() {
      const chuteCollisions = Query.collides(this.chute, [rightWall, leftWall]);
      const bodyCollisions = Query.collides(this.playerBody, [floor]);
      if (bodyCollisions.length > 0) {
        this.chuteForce = 0;
        MBody.setStatic(this.chute, true);
        MBody.setStatic(this.playerBody, true);
        updatePlayerState(this);
      } else if (chuteCollisions.length > 0) {
        this.chuteForce *= -1;
      }
      this.chute.force = Vector.create(this.chuteForce, 0);
      this.playerBody.force = Vector.create(this.chuteForc * 0.5, 0);

      noStroke();
      fill(this.loser ? this.loserColor : this.color);

      drawBody(this.playerBody);
      drawBody(this.chute);
      fill(this.loser ? this.loserColor : color(0));
      stroke(this.loser ? this.loserColor : 255);
      textSize(width / 80);
      textAlign(CENTER, CENTER);
      const { x, y } = this.playerBody.position;
      push();
      translate(x, y);
      // rotate(this.playerBody.angle);
      text(this.name, 0, 0);
      pop();
      if (this.score !== undefined) {
        textSize(width / 40);
        text(this.score, x, y - 50);
      }
    }
  }

  class Circle {
    x = random(windowWidth);
    y = random(windowHeight);
    radius = random(10, 200);
    color = color(random(255), random(255), random(255));
  }

</script>