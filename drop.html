<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/css/toastr.min.css">
<script src="//unpkg.com/twitch-js@>2.0.0-beta.31"></script>
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/js/toastr.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/p5@1.4.0/lib/p5.js"></script>
<script src="token.js"></script>
<script src="libraries/matter.js"></script>
<script src="libraries/helpers.js"></script>
<script lang="javascript">
  const token = 'd6e9352aad4001c8208b3d3bfff374225b88e173';
  const Engine = Matter.Engine;
  const Render = Matter.Render;
  const World = Matter.World;
  const MBody = Matter.Body;
  const Bodies = Matter.Bodies;
  const Vertices = Matter.Vertices;
  const Runner = Matter.Runner;
  const Constraint = Matter.Constraint;
  const Composite = Matter.Composite;
  const Vector = Matter.Vector;
  const Query = Matter.Query;
  const Sleeping = Matter.Sleeping;
  const drawBody = Helpers.drawBody;

  const username = 'jwalter';
  const { chat } = new window.TwitchJs({ username, token: twitchToken });
  let myCircles = [];
  let players = [];
  let targetX = 0;
  let targetWidth;
  let targetHeight;
  let highScorer;

  let boxA;
  let boxB;
  let rightWall;
  let leftWall;
  let ground;
  let floor;
  let timeOfGameStart = 0;
  let maxGameDuration = 60;
  let gameCooldown = 5;

  chat.connect().then(globalUserState => {
    const channel = '#jwalter';    
    chat.join(channel).then(channelState => {
      toastr.options = {
        "positionClass": "toast-bottom-right",
        "newestOnTop": false,
      }

      chat.on('PRIVMSG', privateMessage => {
        console.dir(privateMessage.message);
        if (privateMessage.message.indexOf('!circle') === 0) {
          console.log("Adding circle");
          const commandParts = privateMessage.message.split(" ");
          let circleCount = 1;
          if (commandParts.length > 1) {
            circleCount = parseInt(commandParts[1]);
            if (!isNaN(circleCount)) {
              circleCount = min(100, circleCount);
            }
          }
          for (let index = 0; index < circleCount; index++) {
            const c = new Circle();
            myCircles.push(c);
            World.add(engine.world, c.body);
          }
        } else if (privateMessage.message.indexOf('!fall') === 0) {
          myCircles.forEach(c => {
            Sleeping.set(c.body, false);
          });
        } else if (privateMessage.message.indexOf('!clear') === 0) {
          myCircles.forEach(c => {
            World.remove(engine.world, c.body)
          });
          myCircles = [];
        } else if(privateMessage.message.indexOf('!drop') === 0) {
          if (newGameCanStart()) {
            players.forEach(p => World.remove(engine.world, p.comp));
            players = [];
            highScorer = undefined;
            timeOfGameStart = now();
          }
          if (gameIsActive() && !playerJoined(privateMessage.username)) {
            let emote = undefined;
            if (privateMessage.tags.emotes.length > 0) {
              emote = privateMessage.tags.emotes[0].id;
            }
            const newPlayer = new Player(privateMessage.username, emote);
            players.push(newPlayer);
            World.add(engine.world, newPlayer.comp);
          }
        }
      })
    });

  });

  function now() {
    return new Date().getTime() / 1000;
  }

  function newGameCanStart() {
    return (timeOfGameStart + maxGameDuration + gameCooldown) <= now();
  }

  function gameIsActive() {
    return timeOfGameStart + maxGameDuration >= now();
  }

  function playerJoined(name) {
    return players.find(p => p.name === name) !== undefined;
  }

  function setup() {
    this.width = windowWidth;
    this.height = windowHeight;
    this.targetX = windowWidth / 2;
    this.targetWidth = 200;
    this.targetHeight = 40;
    createCanvas(windowWidth, windowHeight);

     // create an engine
    engine = Engine.create();
    runner = Runner.create();
    
    rightWall = Bodies.rectangle(this.width - 10, this.height / 2, 10, this.height, {
      isStatic: true
    });
    leftWall = Bodies.rectangle(0, this.height / 2, 10, this.height, {
      isStatic: true
    });
    floor = Bodies.rectangle(this.width /2 , this.height  - 10, this.width, 10, {
      isStatic: true
    });
    
    World.add(engine.world, [rightWall, leftWall, floor]);
    Runner.run(runner, engine);
  }
  function draw() {
    clear();
    if (gameIsActive()) {
      push();
      myCircles.forEach(c => {
        fill(c.color);
        circle(c.body.position.x, c.body.position.y, c.radius);
      });
      pop();
      push();
      fill('#ff0000');
      rect(this.targetX - (this.targetWidth / 2), windowHeight - this.targetHeight, this.targetWidth, this.targetHeight);
      pop();
      players.forEach(p => {
        push();
        p.draw();
        pop();
      });

      fill(128);
      drawBody(rightWall);
      drawBody(leftWall);
      drawBody(floor);
    }
  }

  function updatePlayerState(player) {
      let score;
      if (player.score === undefined) {
        score = round(100 - abs(this.targetX - player.playerBody.position.x), 2);
        console.log(`${player.name} scored ${score}`);
        player.score = score;
        player.active = false;
      }
      if (highScorer === undefined || highScorer.score < player.score) {
        if (highScorer !== undefined) {
          highScorer.loser = true;
        }
        console.log(`We have a NEW highscore`);
        highScorer = player;
      } else if (highScorer !== player) {
        console.log(`We have a loser`);
        player.loser = true;
      }
  }

  class Player {
    x = random(windowWidth);
    y = 100;
    xSpeed = random(-5, 5);
    ySpeed = 2;
    name;
    active = true;
    loser = false;
    color = color(random(255), random(255), random(255));
    loserColor = color(0, 42);
    playerBody;
    comp;
    chuteForce = random(-0.1, 0.1);
    image;

    constructor(name, emote) {
      this.name = name;
      if (emote) {
        this.image = loadImage(`https://static-cdn.jtvnw.net/emoticons/v2/${emote}/static/light/2.0`);
      }
      this.playerBody = Bodies.circle(this.x, this.y, 25, 
      { 
        restitution: 0.5,
        density: 0.01
      }
      );
      this.chute = Bodies.fromVertices(this.x, this.y - 100, Vertices.fromPath('35 7 19 17 14 38 14 58 25 79 45 85 65 84 65 66 46 67 34 59 30 44 33 29 45 23 66 23 66 7 53 7'),
      { 
        frictionAir: 1 
      });
      MBody.rotate(this.chute, Math.PI / 2);
      const leftConstraint = Constraint.create({
        bodyA: this.chute,
        bodyB: this.playerBody,
        pointA: Vector.create(-20, 0),
        pointB: Vector.create(-10, 0)
      });
      const rightConstraint = Constraint.create({
        bodyA: this.chute,
        bodyB: this.playerBody,
        pointA: Vector.create(20, 0),
        pointB: Vector.create(10, 0)
      });
      this.comp = Composite.create();
      Composite.add(this.comp, [this.playerBody, this.chute, leftConstraint, rightConstraint]);
      //this.playerBody.force = Vector.create(0.1, 0);
      //this.chute.force = Vector.create(0.1, 0);
    }

    draw() {
      const chuteCollisions = Query.collides(this.chute, [rightWall, leftWall]);
      const bodyCollisions = Query.collides(this.playerBody, [floor]);
      if (bodyCollisions.length > 0) {
        this.chuteForce = 0;
        MBody.setStatic(this.chute, true);
        MBody.setStatic(this.playerBody, true);
        updatePlayerState(this);
      } else if (chuteCollisions.length > 0) {
        this.chuteForce *= -1;
      }
      this.chute.force = Vector.create(this.chuteForce, 0);
      this.playerBody.force = Vector.create(this.chuteForc * 0.5, 0);

      noStroke();
      if (this.loser) {
        console.log("LOSER");
      }
      fill(this.loser ? this.loserColor : this.color);

      if (!this.image) {
        drawBody(this.playerBody);
      }
      drawBody(this.chute);
      fill(this.loser ? this.loserColor : color(0));
      stroke(this.loser ? this.loserColor : 255);
      textSize(width / 70);
      textAlign(CENTER, CENTER);
      const { x, y } = this.playerBody.position;

      push();
      translate(x, y);
      rotate(this.playerBody.angle);
      if (this.image) {
        image(this.image, 0 - this.image.width / 2, 0 - this.image.height / 2);
      }
      text(this.name, 0, 50);
      pop();
      if (this.score !== undefined) {
        textSize(width / 40);
        text(this.score, x, y - 50);
      }
    }
  }

  class Circle {
    x = random(windowWidth);
    y = random(windowHeight);
    radius = random(10, 200);
    color = color(random(255), random(255), random(255));
    body;

    constructor() {
      this.body = Bodies.circle(this.x, this.y, this.radius / 2,
      { 
        restitution: 1.2
      });
      
      Sleeping.set(this.body, true);
    }
  }

</script>