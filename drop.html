<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/css/toastr.min.css">
<script src="//unpkg.com/twitch-js@>2.0.0-beta.31"></script>
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/toastr.js/latest/js/toastr.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/p5@1.4.0/lib/p5.js"></script>
<script src="token.js"></script>
<script src="libraries/matter.js"></script>
<script src="libraries/helpers.js"></script>
<script lang="javascript">
  const Engine = Matter.Engine;
  const Render = Matter.Render;
  const World = Matter.World;
  const MBody = Matter.Body;
  const Bodies = Matter.Bodies;
  const Vertices = Matter.Vertices;
  const Runner = Matter.Runner;
  const Constraint = Matter.Constraint;
  const Composite = Matter.Composite;
  
  const drawBody = Helpers.drawBody;

  const username = 'jwalter';
  const { chat } = new window.TwitchJs({ username, token: twitchToken });
  let myCircles = [];
  let players = [];
  let targetX = 0;
  let targetWidth;
  let targetHeight;
  let highScorer;

  let boxA;
  let boxB;
  let rightWall;
  let leftWall;
  let ground;
  let floor;

  chat.connect().then(globalUserState => {
    const channel = '#jwalter';    
    chat.join(channel).then(channelState => {
      toastr.options = {
        "positionClass": "toast-bottom-right",
        "newestOnTop": false,
      }

      chat.on('PRIVMSG', privateMessage => {
        console.dir(privateMessage.message);
        console.log(privateMessage.message.indexOf('!circle'));
        if (privateMessage.message.indexOf('!circle') === 0) {
          console.log("Adding circle");
          myCircles.push(new Circle());
        } else if(privateMessage.message.indexOf('!drop') === 0) {
          const newPlayer = new Player(privateMessage.username);
          players.push(newPlayer);
          World.add(engine.world, newPlayer.comp);
          // World.add(engine.world, newPlayer.chute);
        }
      })
    });

  });

  function setup() {
    this.width = windowWidth;
    this.height = windowHeight;
    this.targetX = windowWidth / 2;
    this.targetWidth = 200;
    this.targetHeight = 40;
    createCanvas(windowWidth, windowHeight);

     // create an engine
    engine = Engine.create();
    runner = Runner.create();

    // create two boxes and a ground
    boxA = Bodies.rectangle(200, 200, 80, 80);
    boxB = Bodies.rectangle(270, 50, 160, 80);
    rightWall = Bodies.rectangle(this.width - 10, this.height / 2, 10, this.height, {
      isStatic: true
    });
    leftWall = Bodies.rectangle(0, this.height / 2, 10, this.height, {
      isStatic: true
    });
    floor = Bodies.rectangle(this.width /2 , this.height  - 10, this.width, 10, {
      isStatic: true
    });
    
    ground = Bodies.rectangle(400, 500, 810, 10, {
      isStatic: true, angle: Math.PI * 0.06
    });
    World.add(engine.world, [boxA, boxB, ground, rightWall, leftWall, floor]);
    Runner.run(runner, engine);
  }
  function draw() {
    clear();
    push();
    myCircles.forEach(c => {
      fill(c.color);
      circle(c.x, c.y, c.radius);
    });
    pop();
    push();
    fill('#ff0000');
    rect(this.targetX - (this.targetWidth / 2), windowHeight - this.targetHeight, this.targetWidth, this.targetHeight);
    pop();
    players.forEach(p => {
      push();
      p.draw();
      pop();
      if (p.active || !p.loser) {
        this.updatePlayerState(p);
      }
    });
    fill(255);
    drawBody(boxA);
    drawBody(boxB);

    fill(128);
    drawBody(ground);
    drawBody(rightWall);
    drawBody(leftWall);
    drawBody(floor);
  }

  function updatePlayerState(player) {
    if (player.y > windowHeight - this.targetHeight) {
      const distance = abs(this.targetX - player.x);
      const score = 100 - distance;
      player.score = round(score, 2);
      player.active = false;
      if (this.highScorer === undefined || this.highScorer.score < player.score) {
        this.highScorer = player;
      } else if (this.highScorer !== player) {
        player.loser = true;
      }
    }
  }

  class Player {
    x = random(windowWidth);
    y = 0;
    xSpeed = random(-5, 5);
    ySpeed = 2;
    name;
    active = true;
    loser = false;
    color = color(random(255), random(255), random(255));
    loserColor = color(0, 42);
    pc;
    comp;
    constructor(name) {
      this.name = name;
      this.pc = Bodies.circle(this.x, this.y, 25, { restitution: 0.5 });
      this.chute = Bodies.fromVertices(this.x, this.y, Vertices.fromPath('35 7 19 17 14 38 14 58 25 79 45 85 65 84 65 66 46 67 34 59 30 44 33 29 45 23 66 23 66 7 53 7'),
      { frictionAir: 0.5 });
      const constraint = Constraint.create({
        bodyA: this.chute,
        bodyB: this.pc
      });
      // MBody.applyForce(this.pc, Matter.Vector.create(0, 0), Matter.Vector.create(-0.3, 0));
      this.comp = Composite.create();
      Composite.add(this.comp, [this.pc, this.chute, constraint]);
    }

    draw() {
      noStroke();
      push();
      fill(this.color);
      drawBody(this.pc);
      drawBody(this.chute);
      fill(color(0));
      textSize(width / 40);
      textAlign(CENTER, CENTER);
      stroke(this.loser ? this.loserColor : 255);
      const { x, y } = this.pc.position;
      text(this.name, x, y);
      pop();
      fill(this.loser ? this.loserColor : this.color);
      circle(this.x, this.y, 50);
      fill(this.loser ? this.loserColor : color(0));
      textSize(width / 40);
      textAlign(CENTER, CENTER);
      stroke(this.loser ? this.loserColor : 255);
      text(this.name, this.x, this.y);
      if (this.active) {
        this.y += this.ySpeed;
        this.x += this.xSpeed;
        if (this.x < 0) {
          this.xSpeed = -this.xSpeed;
        } else if (this.x > windowWidth) {
          this.xSpeed = -this.xSpeed;
        }
      } else {
        text(this.score, this.x, this.y - 50);
      }
    }
  }

  class Circle {
    x = random(windowWidth);
    y = random(windowHeight);
    radius = random(10, 200);
    color = color(random(255), random(255), random(255));
  }

</script>